from py4godot.utils.VariantTypeWrapper4 import *
import py4godot.classes.Object.Object as __object__

import py4godot.classes.core as __core__
import py4godot.classes.typedarrays as __typedarrays__
from py4godot.signals import BuiltinSignal


class Object():
  script_changed: BuiltinSignal
  property_list_changed: BuiltinSignal

  @staticmethod
  def constructor()->Object:pass



  def get_pyscript(self)->Object:pass
  @staticmethod
  def cast(other:__object__.Object)->Object:pass


  def get_class(self)->str: pass

  def is_class(self, class_:str)->bool: pass

  def set(self, property:__core__.StringName, value:object)->None: pass

  def get(self, property:__core__.StringName)->object: pass

  def set_indexed(self, property_path:__core__.NodePath, value:object)->None: pass

  def get_indexed(self, property_path:__core__.NodePath)->object: pass

  def get_property_list(self)->__core__.Array: pass

  def get_method_list(self)->__core__.Array: pass

  def property_can_revert(self, property:__core__.StringName)->bool: pass

  def property_get_revert(self, property:__core__.StringName)->object: pass

  def notification(self, what:int, reversed:bool=False)->None: pass

  def to_string(self)->str: pass

  def get_instance_id(self)->int: pass

  def set_script(self, script:object)->None: pass

  def get_script(self)->object: pass

  def set_meta(self, name:__core__.StringName, value:object)->None: pass

  def remove_meta(self, name:__core__.StringName)->None: pass

  def get_meta(self, name:__core__.StringName, default:object=None)->object: pass

  def has_meta(self, name:__core__.StringName)->bool: pass

  def get_meta_list(self)->__core__.Array: pass

  def add_user_signal(self, signal:str, arguments:__core__.Array= __core__.Array.new0())->None: pass

  def has_user_signal(self, signal:__core__.StringName)->bool: pass

  def remove_user_signal(self, signal:__core__.StringName)->None: pass

  def emit_signal(self, signal:__core__.StringName)->int: pass

  def call(self, method:__core__.StringName)->object: pass

  def call_deferred(self, method:__core__.StringName)->object: pass

  def set_deferred(self, property:__core__.StringName, value:object)->None: pass

  def callv(self, method:__core__.StringName, arg_array:__core__.Array)->object: pass

  def has_method(self, method:__core__.StringName)->bool: pass

  def get_method_argument_count(self, method:__core__.StringName)->int: pass

  def has_signal(self, signal:__core__.StringName)->bool: pass

  def get_signal_list(self)->__core__.Array: pass

  def get_signal_connection_list(self, signal:__core__.StringName)->__core__.Array: pass

  def get_incoming_connections(self)->__core__.Array: pass

  def connect(self, signal:__core__.StringName, callable:__core__.Callable, flags:int=0)->int: pass

  def disconnect(self, signal:__core__.StringName, callable:__core__.Callable)->None: pass

  def is_connected(self, signal:__core__.StringName, callable:__core__.Callable)->bool: pass

  def set_block_signals(self, enable:bool)->None: pass

  def is_blocking_signals(self)->bool: pass

  def notify_property_list_changed(self)->None: pass

  def set_message_translation(self, enable:bool)->None: pass

  def can_translate_messages(self)->bool: pass

  def tr(self, message:__core__.StringName, context:__core__.StringName= __core__.StringName.new0())->str: pass

  def tr_n(self, message:__core__.StringName, plural_message:__core__.StringName, n:int, context:__core__.StringName= __core__.StringName.new0())->str: pass

  def is_queued_for_deletion(self)->bool: pass

  def cancel_free(self)->None: pass


