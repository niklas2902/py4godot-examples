from py4godot.utils.VariantTypeWrapper4 import *
import py4godot.classes.Object.Object as __object__

import py4godot.classes.core as __core__
import py4godot.classes.typedarrays as __typedarrays__
from py4godot.signals import BuiltinSignal
import py4godot.classes.RDSamplerState.RDSamplerState as __rdsamplerstate__
import py4godot.classes.RDPipelineMultisampleState.RDPipelineMultisampleState as __rdpipelinemultisamplestate__
import py4godot.classes.Object.Object as __object__
import py4godot.classes.RDShaderSPIRV.RDShaderSPIRV as __rdshaderspirv__
import py4godot.classes.RDPipelineDepthStencilState.RDPipelineDepthStencilState as __rdpipelinedepthstencilstate__
import py4godot.classes.RDPipelineColorBlendState.RDPipelineColorBlendState as __rdpipelinecolorblendstate__
import py4godot.classes.RDShaderSource.RDShaderSource as __rdshadersource__
import py4godot.classes.RDTextureView.RDTextureView as __rdtextureview__
import py4godot.classes.RDPipelineRasterizationState.RDPipelineRasterizationState as __rdpipelinerasterizationstate__
import py4godot.classes.RenderingDevice.RenderingDevice as __renderingdevice__
import py4godot.classes.RDTextureFormat.RDTextureFormat as __rdtextureformat__


class RenderingDevice(__object__.Object):

  @staticmethod
  def constructor()->RenderingDevice:pass



  @staticmethod
  def cast(other:__object__.Object)->RenderingDevice:pass


  def texture_create(self, format:__rdtextureformat__.RDTextureFormat, view:__rdtextureview__.RDTextureView, data:__core__.Array=[])->__core__.RID: pass

  def texture_create_shared(self, view:__rdtextureview__.RDTextureView, with_texture:__core__.RID)->__core__.RID: pass

  def texture_create_shared_from_slice(self, view:__rdtextureview__.RDTextureView, with_texture:__core__.RID, layer:int, mipmap:int, mipmaps:int=1, slice_type:int =0)->__core__.RID: pass

  def texture_create_from_extension(self, type:int , format:int , samples:int , usage_flags:int, image:int, width:int, height:int, depth:int, layers:int)->__core__.RID: pass

  def texture_update(self, texture:__core__.RID, layer:int, data:__core__.PackedByteArray)->int: pass

  def texture_get_data(self, texture:__core__.RID, layer:int)->__core__.PackedByteArray: pass

  def texture_is_format_supported_for_usage(self, format:int , usage_flags:int)->bool: pass

  def texture_is_shared(self, texture:__core__.RID)->bool: pass

  def texture_is_valid(self, texture:__core__.RID)->bool: pass

  def texture_copy(self, from_texture:__core__.RID, to_texture:__core__.RID, from_pos:__core__.Vector3, to_pos:__core__.Vector3, size:__core__.Vector3, src_mipmap:int, dst_mipmap:int, src_layer:int, dst_layer:int)->int: pass

  def texture_clear(self, texture:__core__.RID, color:__core__.Color, base_mipmap:int, mipmap_count:int, base_layer:int, layer_count:int)->int: pass

  def texture_resolve_multisample(self, from_texture:__core__.RID, to_texture:__core__.RID)->int: pass

  def texture_get_format(self, texture:__core__.RID)->__rdtextureformat__.RDTextureFormat: pass

  def texture_get_native_handle(self, texture:__core__.RID)->int: pass

  def framebuffer_format_create(self, attachments:__core__.Array, view_count:int=1)->int: pass

  def framebuffer_format_create_multipass(self, attachments:__core__.Array, passes:__core__.Array, view_count:int=1)->int: pass

  def framebuffer_format_create_empty(self, samples:int =0)->int: pass

  def framebuffer_format_get_texture_samples(self, format:int, render_pass:int=0)->int: pass

  def framebuffer_create(self, textures:__core__.Array, validate_with_format:int=-1, view_count:int=1)->__core__.RID: pass

  def framebuffer_create_multipass(self, textures:__core__.Array, passes:__core__.Array, validate_with_format:int=-1, view_count:int=1)->__core__.RID: pass

  def framebuffer_create_empty(self, size:__core__.Vector2i, samples:int =0, validate_with_format:int=-1)->__core__.RID: pass

  def framebuffer_get_format(self, framebuffer:__core__.RID)->int: pass

  def framebuffer_is_valid(self, framebuffer:__core__.RID)->bool: pass

  def sampler_create(self, state:__rdsamplerstate__.RDSamplerState)->__core__.RID: pass

  def sampler_is_format_supported_for_filter(self, format:int , sampler_filter:int )->bool: pass

  def vertex_buffer_create(self, size_bytes:int, data:__core__.PackedByteArray= __core__.PackedByteArray.new0(), use_as_storage:bool=False)->__core__.RID: pass

  def vertex_format_create(self, vertex_descriptions:__core__.Array)->int: pass

  def vertex_array_create(self, vertex_count:int, vertex_format:int, src_buffers:__core__.Array, offsets:__core__.PackedInt64Array= __core__.PackedInt64Array.new0())->__core__.RID: pass

  def index_buffer_create(self, size_indices:int, format:int , data:__core__.PackedByteArray= __core__.PackedByteArray.new0(), use_restart_indices:bool=False)->__core__.RID: pass

  def index_array_create(self, index_buffer:__core__.RID, index_offset:int, index_count:int)->__core__.RID: pass

  def shader_compile_spirv_from_source(self, shader_source:__rdshadersource__.RDShaderSource, allow_cache:bool=True)->__rdshaderspirv__.RDShaderSPIRV: pass

  def shader_compile_binary_from_spirv(self, spirv_data:__rdshaderspirv__.RDShaderSPIRV, name:str= __core__.String.new0())->__core__.PackedByteArray: pass

  def shader_create_from_spirv(self, spirv_data:__rdshaderspirv__.RDShaderSPIRV, name:str= __core__.String.new0())->__core__.RID: pass

  def shader_create_from_bytecode(self, binary_data:__core__.PackedByteArray, placeholder_rid:__core__.RID= __core__.RID.new0())->__core__.RID: pass

  def shader_create_placeholder(self)->__core__.RID: pass

  def shader_get_vertex_input_attribute_mask(self, shader:__core__.RID)->int: pass

  def uniform_buffer_create(self, size_bytes:int, data:__core__.PackedByteArray= __core__.PackedByteArray.new0())->__core__.RID: pass

  def storage_buffer_create(self, size_bytes:int, data:__core__.PackedByteArray= __core__.PackedByteArray.new0(), usage:int=0)->__core__.RID: pass

  def texture_buffer_create(self, size_bytes:int, format:int , data:__core__.PackedByteArray= __core__.PackedByteArray.new0())->__core__.RID: pass

  def uniform_set_create(self, uniforms:__core__.Array, shader:__core__.RID, shader_set:int)->__core__.RID: pass

  def uniform_set_is_valid(self, uniform_set:__core__.RID)->bool: pass

  def buffer_copy(self, src_buffer:__core__.RID, dst_buffer:__core__.RID, src_offset:int, dst_offset:int, size:int)->int: pass

  def buffer_update(self, buffer:__core__.RID, offset:int, size_bytes:int, data:__core__.PackedByteArray)->int: pass

  def buffer_clear(self, buffer:__core__.RID, offset:int, size_bytes:int)->int: pass

  def buffer_get_data(self, buffer:__core__.RID, offset_bytes:int=0, size_bytes:int=0)->__core__.PackedByteArray: pass

  def render_pipeline_create(self, shader:__core__.RID, framebuffer_format:int, vertex_format:int, primitive:int , rasterization_state:__rdpipelinerasterizationstate__.RDPipelineRasterizationState, multisample_state:__rdpipelinemultisamplestate__.RDPipelineMultisampleState, stencil_state:__rdpipelinedepthstencilstate__.RDPipelineDepthStencilState, color_blend_state:__rdpipelinecolorblendstate__.RDPipelineColorBlendState, dynamic_state_flags:int=0, for_render_pass:int=0, specialization_constants:__core__.Array=Array[RDPipelineSpecializationConstant]([]))->__core__.RID: pass

  def render_pipeline_is_valid(self, render_pipeline:__core__.RID)->bool: pass

  def compute_pipeline_create(self, shader:__core__.RID, specialization_constants:__core__.Array=Array[RDPipelineSpecializationConstant]([]))->__core__.RID: pass

  def compute_pipeline_is_valid(self, compute_pipeline:__core__.RID)->bool: pass

  def screen_get_width(self, screen:int=0)->int: pass

  def screen_get_height(self, screen:int=0)->int: pass

  def screen_get_framebuffer_format(self, screen:int=0)->int: pass

  def draw_list_begin_for_screen(self, screen:int=0, clear_color:__core__.Color= __core__.Color.new0())->int: pass

  def draw_list_begin(self, framebuffer:__core__.RID, initial_color_action:int , final_color_action:int , initial_depth_action:int , final_depth_action:int , clear_color_values:__core__.PackedColorArray= __core__.PackedColorArray.new0(), clear_depth:float=1.0, clear_stencil:int=0, region:__core__.Rect2= __core__.Rect2.new0())->int: pass

  def draw_list_begin_split(self, framebuffer:__core__.RID, splits:int, initial_color_action:int , final_color_action:int , initial_depth_action:int , final_depth_action:int , clear_color_values:__core__.PackedColorArray= __core__.PackedColorArray.new0(), clear_depth:float=1.0, clear_stencil:int=0, region:__core__.Rect2= __core__.Rect2.new0(), storage_textures:__core__.Array=Array[RID]([]))->__core__.PackedInt64Array: pass

  def draw_list_set_blend_constants(self, draw_list:int, color:__core__.Color)->None: pass

  def draw_list_bind_render_pipeline(self, draw_list:int, render_pipeline:__core__.RID)->None: pass

  def draw_list_bind_uniform_set(self, draw_list:int, uniform_set:__core__.RID, set_index:int)->None: pass

  def draw_list_bind_vertex_array(self, draw_list:int, vertex_array:__core__.RID)->None: pass

  def draw_list_bind_index_array(self, draw_list:int, index_array:__core__.RID)->None: pass

  def draw_list_set_push_constant(self, draw_list:int, buffer:__core__.PackedByteArray, size_bytes:int)->None: pass

  def draw_list_draw(self, draw_list:int, use_indices:bool, instances:int, procedural_vertex_count:int=0)->None: pass

  def draw_list_enable_scissor(self, draw_list:int, rect:__core__.Rect2= __core__.Rect2.new0())->None: pass

  def draw_list_disable_scissor(self, draw_list:int)->None: pass

  def draw_list_switch_to_next_pass(self)->int: pass

  def draw_list_switch_to_next_pass_split(self, splits:int)->__core__.PackedInt64Array: pass

  def draw_list_end(self)->None: pass

  def compute_list_begin(self)->int: pass

  def compute_list_bind_compute_pipeline(self, compute_list:int, compute_pipeline:__core__.RID)->None: pass

  def compute_list_set_push_constant(self, compute_list:int, buffer:__core__.PackedByteArray, size_bytes:int)->None: pass

  def compute_list_bind_uniform_set(self, compute_list:int, uniform_set:__core__.RID, set_index:int)->None: pass

  def compute_list_dispatch(self, compute_list:int, x_groups:int, y_groups:int, z_groups:int)->None: pass

  def compute_list_dispatch_indirect(self, compute_list:int, buffer:__core__.RID, offset:int)->None: pass

  def compute_list_add_barrier(self, compute_list:int)->None: pass

  def compute_list_end(self)->None: pass

  def free_rid(self, rid:__core__.RID)->None: pass

  def capture_timestamp(self, name:str)->None: pass

  def get_captured_timestamps_count(self)->int: pass

  def get_captured_timestamps_frame(self)->int: pass

  def get_captured_timestamp_gpu_time(self, index:int)->int: pass

  def get_captured_timestamp_cpu_time(self, index:int)->int: pass

  def get_captured_timestamp_name(self, index:int)->str: pass

  def limit_get(self, limit:int )->int: pass

  def get_frame_delay(self)->int: pass

  def submit(self)->None: pass

  def sync(self)->None: pass

  def barrier(self, from_:int=32767, to:int=32767)->None: pass

  def full_barrier(self)->None: pass

  def create_local_device(self)->__renderingdevice__.RenderingDevice: pass

  def set_resource_name(self, id:__core__.RID, name:str)->None: pass

  def draw_command_begin_label(self, name:str, color:__core__.Color)->None: pass

  def draw_command_insert_label(self, name:str, color:__core__.Color)->None: pass

  def draw_command_end_label(self)->None: pass

  def get_device_vendor_name(self)->str: pass

  def get_device_name(self)->str: pass

  def get_device_pipeline_cache_uuid(self)->str: pass

  def get_memory_usage(self, type:int )->int: pass

  def get_driver_resource(self, resource:int , rid:__core__.RID, index:int)->int: pass


