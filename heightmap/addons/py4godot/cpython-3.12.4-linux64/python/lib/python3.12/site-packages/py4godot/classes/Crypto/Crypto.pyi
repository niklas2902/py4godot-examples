from py4godot.utils.VariantTypeWrapper4 import *
import py4godot.classes.Object.Object as __object__

import py4godot.classes.core as __core__
import py4godot.classes.typedarrays as __typedarrays__
from py4godot.signals import BuiltinSignal
import py4godot.classes.RefCounted.RefCounted as __refcounted__
import py4godot.classes.CryptoKey.CryptoKey as __cryptokey__
import py4godot.classes.X509Certificate.X509Certificate as __x509certificate__
import py4godot.classes.HashingContext.HashingContext as __hashingcontext__


class Crypto(__refcounted__.RefCounted):

  @staticmethod
  def constructor()->Crypto:pass



  @staticmethod
  def cast(other:__object__.Object)->Crypto:pass


  def generate_random_bytes(self, size:int)->__core__.PackedByteArray: pass

  def generate_rsa(self, size:int)->__cryptokey__.CryptoKey: pass

  def generate_self_signed_certificate(self, key:__cryptokey__.CryptoKey, issuer_name:str= __core__.String.new0(), not_before:str= __core__.String.new0(), not_after:str= __core__.String.new0())->__x509certificate__.X509Certificate: pass

  def sign(self, hash_type:int , hash:__core__.PackedByteArray, key:__cryptokey__.CryptoKey)->__core__.PackedByteArray: pass

  def verify(self, hash_type:int , hash:__core__.PackedByteArray, signature:__core__.PackedByteArray, key:__cryptokey__.CryptoKey)->bool: pass

  def encrypt(self, key:__cryptokey__.CryptoKey, plaintext:__core__.PackedByteArray)->__core__.PackedByteArray: pass

  def decrypt(self, key:__cryptokey__.CryptoKey, ciphertext:__core__.PackedByteArray)->__core__.PackedByteArray: pass

  def hmac_digest(self, hash_type:int , key:__core__.PackedByteArray, msg:__core__.PackedByteArray)->__core__.PackedByteArray: pass

  def constant_time_compare(self, trusted:__core__.PackedByteArray, received:__core__.PackedByteArray)->bool: pass


